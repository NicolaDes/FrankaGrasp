#!/usr/bin/python
# Point cloud util configuration

PACKAGE='point_cloud_utils'
import roslib; roslib.load_manifest(PACKAGE)

#from math import pi

#from driver_base.msg import SensorLevels
from dynamic_reconfigure.parameter_generator import *

gen = ParameterGenerator()
#       Name                    Type      Reconfiguration level             Description                                                                                      Default    Min   Max
#gen.add("run",                  bool_t,   0,                                "Whether or not the util node is running.",                                                      False)
#gen.add("debug",                bool_t,   0,                                "Whether or not to print debug messages.",                                                       False)
#gen.add("transform_to_global",  bool_t,   0,                                "Whether or not to transform point cloud to global frame.",                                        False)
#gen.add("clean_missing_points", bool_t,   0,                                "Whether or not to clean NaN points.",                                             True)
#gen.add("remove_plane",         bool_t,   0,                                "Whether or not to use RANSAC to remove the plane.",                                             False)
#gen.add("ransac_tol",           double_t, 0,                                "The tolerance for plane detection.",                                                            0.025,     0,    0.1)
#gen.add("ransac_iter",          int_t,    0,                                "The number of iterations to run ransac for.",                                                   20,        1,    100)
#gen.add("remove_outlier",       bool_t,   0,                                "Whether or not to use remove outliers using statistical outlier removal.",                                             False)
#gen.add("outlier_mean_k",       int_t,    0,                                "The number of points (k) to use for mean distance estimation.",                                                   50,        1,    200)
#gen.add("outlier_StddevMulThresh", double_t, 0,                                "The standard deviation multiplier threshold. All points outside the +/- * std_mul will be considered outliers.",                                                1.0,     0,    10)
#gen.add("remove_user_plane",    bool_t,   0,                                "Whether or not to remove a user-specified plane.  All points with ax+by+cz+d >= 0 are kept.",                                             False)
#gen.add("user_plane_a",         double_t, 0,                                "Value of a for user-specified plane..",                                                            0)
#gen.add("user_plane_b",         double_t, 0,                                "Value of b for user-specified plane..",                                                            0)
#gen.add("user_plane_c",         double_t, 0,                                "Value of c for user-specified plane..",                                                            0)
#gen.add("user_plane_d",         double_t, 0,                                "Value of d for user-specified plane..",                                                            1)
#gen.add("estimate_normals",     bool_t,   0,                                "Whether or not to estimate normals.",                                             False)
#gen.add("normals_k_neighbors",  int_t,    0,                                "The number of neighboring points (k) to use for normal estimation.",                               20,        1,    200)
#gen.add("write_binary",         bool_t,   0,                                "Whether or not to write as a binary file.",                                                     False)
#gen.add("write_depth_map",      bool_t,   0,                                "Whether or not to save the disparity image.",                                                     False)
#gen.add("write_ascii_precision",int_t,    0,                                "The level of precision for writing as ascii",                                                   12,         1,   99)
gen.add("write_next",           bool_t,   0,                         	       "Whether or not to save the next point cloud to file.",                                          False)
#gen.add("write_file_prefix",    str_t,    0,                                "The prefix of the file to write.",                                         "pcd")
#gen.add("write_file_num",       int_t,    0,                                "The number of the next file to write",                                                   0,         0,    9999)
# gen.add("skip",                 int_t,    0,                                "The number of scans to skip between each measured scan",                                        0,         0,    9)
# gen.add("port",                 str_t,    SensorLevels.RECONFIGURE_CLOSE,   "The serial port where the hokuyo device can be found",                                          "/dev/ttyACM0")
# gen.add("calibrate_time",       bool_t,   SensorLevels.RECONFIGURE_CLOSE,   "Whether the node should calibrate the hokuyo's time offset",                                    True)
# gen.add("frame_id",             str_t,    SensorLevels.RECONFIGURE_RUNNING, "The frame in which laser scans will be returned",                                               "laser")
# gen.add("time_offset",          double_t, SensorLevels.RECONFIGURE_RUNNING, "An offet to add to the timestamp before publication of a scan",                                 0,     -0.25, 0.25)
# gen.add("allow_unsafe_settings",bool_t,   SensorLevels.RECONFIGURE_CLOSE,   "Turn this on if you wish to use the UTM-30LX with an unsafe angular range. Turning this option on may cause occasional crashes or bad data. This option is a tempory workaround that will hopefully be removed in an upcoming driver version.", False)

exit(gen.generate(PACKAGE, "util", "util"))
