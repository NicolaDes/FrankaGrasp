/*
 * David Fischinger -TUW
 * 27.10. 2011
 *
 *	use first pc_mirror and then pc_cut!
 *	usage: change path, change runningNumber limits in for-loop
 *
 * input:
 *
 *   reads pcd files from folder
 *
 * output:
 *
 *   subtracts fixed value from all z-coordinates s.t. highest point is about 6,7,8,... cm high
 *   resulting z-coordinates < 0 are set to 0
 *   saves output clouds (like filenameold_hN.pcd where N = highest point (floored) in cm)
 *
 */

#include <iostream>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include "pcl/io/io.h"
#include "std_msgs/String.h"
#include <string.h>
#include <sstream>


using namespace std;


int main (int argc, char** argv)
{
	//PATH where file are read from
	string path = "/home/grasp/David/GPDatabase/badgps/twocams/badmanual/";


	// loop which reads all pcd-files
	for (int runningNumber = 2000; runningNumber < 2251; runningNumber++)
	{
		cout << "\n runningNumber: " << runningNumber << "\n";
		//defines if basic PCs are taken:
		//type 0: "pcd_nr.pcd"		or
		//type 1: "pcd_nr_x.pcd" 	mirrored by x values or
		//type 2: "pcd_nr_y.pcd" 	mirrord PCs by y values or
		//type 3: "pcd_nr_b.pcd"	mirrored PCs by x- and y-values
		for (int mirror_type = 0; mirror_type < 4; mirror_type++){
			string mtype;
			switch (mirror_type){
				case 0:
					mtype = ".pcd"; break;
				case 1:
					mtype = "_x.pcd"; break;
				case 2:
					mtype = "_y.pcd"; break;
				case 3:
					mtype = "_b.pcd"; break;
				default:
					break;
			}
			stringstream ss_file_in;

			pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in (new pcl::PointCloud<pcl::PointXYZ>);

			ss_file_in << path << "pcd_" << runningNumber << mtype;

			if (pcl::io::loadPCDFile<pcl::PointXYZ> (ss_file_in.str(), *cloud_in) == -1) //load the file
			{
				cout << "\n Couldn't read file (%d) \n" << runningNumber << endl;
				continue;
			}

			//find highest z-coordinate
			double z_max = 0;
			for (int i = 0; i < cloud_in->points.size(); ++i)
			{
				if (cloud_in->points[i].z > z_max){
					z_max = cloud_in->points[i].z;
				}
			}
			int z_max_int = (int) (100*z_max);

			//reduce height in 1cm steps until highest point is about 6cm, save all resulting PCs as pcd-files
			for (int k = z_max_int-6; k >= 0; --k)
			{
				pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out (new pcl::PointCloud<pcl::PointXYZ>);
				stringstream ss_file_out;
				ss_file_out << path << "pcd_" << runningNumber << "_h" << z_max_int-k << mtype;

				pcl::copyPointCloud<pcl::PointXYZ>(*cloud_in, *cloud_out);

				//manipulate pcd
				for (int i = 0; i < cloud_in->points.size(); ++i)
				{
					cloud_out->points[i].z = cloud_out->points[i].z - k*0.01;
					if (cloud_out->points[i].z < 0){
						cloud_out->points[i].z = 0;
					}
				}
				//save point cloud
				pcl::io::savePCDFile(ss_file_out.str(), *cloud_out);

			}
		}
	}

	return (0);
}
