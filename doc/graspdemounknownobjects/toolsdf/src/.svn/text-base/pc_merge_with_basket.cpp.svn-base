/*
 *
 * David Fischinger -TUW
 * 8.11. 2011
 *
 * input:
 *
 *   pointcloud from camera1 read from topic /SS/camera/depth/points
 *   pointcloud from camera2 read from topic /SS/camera2/depth/points
 *
 * output:
 *   pointcloud merged, filtered, downsampled and segmented from the two, points of basket subtracted
 *   publishes the center of the detected basket (assuming there is a basket!)
 *
 *   output point cloud w.r.t. tf_frame /world on topic /SS/points2_without_basket_wcs
 *
 *
 * PARAMETERS:
 *
 * 	 use_two_cams = false;			//if one ore two cameras are used
 *
 */

#include <iostream>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include "pcl/io/io.h"
#include "pcl_ros/publisher.h"
#include "pcl_ros/transforms.h"
#include <pcl/filters/passthrough.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/features/normal_3d.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/kdtree/kdtree.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/sample_consensus/ransac.h>
#include <pcl/sample_consensus/sac_model_plane.h>
#include <pcl/sample_consensus/sac_model_line.h>

#include <boost/thread/thread.hpp>

#include "ros/ros.h"
#include "std_msgs/String.h"
#include "sensor_msgs/PointCloud2.h"

#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <sensor_msgs/PointCloud2.h>

// PCL specific includes
#include <pcl/ros/conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/point_types.h>
#include <pcl_ros/point_cloud.h>

#include <boost/thread/mutex.hpp>

#include <PCLFunctions.hpp>

#include <tf/tf.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include "pcl_ros/transforms.h"

#include "tf/tf.h"
#include "tf/transform_broadcaster.h"
#include "tf/transform_datatypes.h"
#include "tf/transform_listener.h"

#include <sstream>

using namespace std;

tf::TransformListener *tf_listener;


class CPCMerge
{
public:
	bool pc_cam1_filled, pc_cam2_filled;
	bool use_two_cams;
	ros::Publisher pc_merged_pub;
	ros::Publisher nr_segmented_pc_pub;
	ros::Publisher pc_for_basketdet_pub;
	ros::Publisher pc_for_basketdet_cam1_pub;		//in camera coordinate system, basket points eliminated
	ros::Publisher center_basket_pub;
	ros::Subscriber pc_cam1_sub;
	ros::Subscriber pc_cam2_sub;
	sensor_msgs::PointCloud2 pc_cam1;
	sensor_msgs::PointCloud2 pc_cam2;
	sensor_msgs::PointCloud2 pc_for_basketdet_out;
  	ros::NodeHandle nh;
  	boost::mutex m;

	pcl::PointCloud<pcl::PointXYZ> pcl_cloud_cam1_without_basket;


	void publish_merged_pc();  	//merges pointclouds from 2 different cameras
	void filter_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged,
			       bool pub_basket_center=true, float x_min=0.6, float x_max=1.3,
			       float y_min=-0.6, float y_max=0.0, float z_min=0.04, float z_max = 1.0 );//filters outliers and points outside difined region
	void filter_pc_add_xyz(pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_merged,
			               pcl::PointCloud<PointXYZRC>::Ptr final_cloud,
			               bool pub_basket_center=true, float x_min=0.6, float x_max=1.3,
			               float y_min=-0.6, float y_max=0.0, float z_min=0.04, float z_max = 1.0  );
	void downsampling_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged);
	void segment_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged );
	void pc_cam1_callback(const sensor_msgs::PointCloud2ConstPtr& pcl_in); //saves pc from cam1
	void pc_cam2_callback(const sensor_msgs::PointCloud2ConstPtr& pcl_in); //saves pc from cam2

	CPCMerge(ros::NodeHandle nh)
	{
		this->nh = nh;
		pc_cam1_filled = pc_cam2_filled = false;
		use_two_cams = false;
		//define publisher
		this->pc_merged_pub = nh.advertise<sensor_msgs::PointCloud2>("SS/points2", 5);
		this->pc_for_basketdet_pub = nh.advertise<sensor_msgs::PointCloud2>("/SS/points2_without_basket_wcs",1); //david
		pc_for_basketdet_cam1_pub = nh.advertise<pcl::PointCloud<PointXYZRC> >("/SS/camera/depth/points_without_basket",1); //kate
		this->center_basket_pub = nh.advertise<std_msgs::String>("/SS/basket_center",1);
		this->nr_segmented_pc_pub = nh.advertise<std_msgs::String>("pc_merge/nr_segmented_pcs", 1); //publish nr of segmented point clouds
		//define subscriber
		this->pc_cam1_sub = nh.subscribe("/SS/camera/depth/points",1, &CPCMerge::pc_cam1_callback, this);
		if (use_two_cams)
			this->pc_cam2_sub = nh.subscribe("/SS/camera2/depth/points",1, &CPCMerge::pc_cam2_callback, this);
	}
};

void CPCMerge::publish_merged_pc()
{
	ROS_INFO("publish_merged_pc() started");
	pcl::PointCloud<pcl::PointXYZ> pcl_cloud_cam1;
	pcl::PointCloud<pcl::PointXYZ> pcl_cloud_merged;
	pcl::fromROSMsg (pc_cam1, pcl_cloud_cam1);
	pcl_cloud_merged = pcl_cloud_cam1;

	//if second camera is used, then merge the(&pcl_cloud_m two point clouds (otherway only pc from one camera is used
	if (use_two_cams){
		pcl::PointCloud<pcl::PointXYZ> pcl_cloud_cam2;
		pcl::fromROSMsg (pc_cam2, pcl_cloud_cam2);
		pcl_cloud_merged+= pcl_cloud_cam2;
	}

	//Filter Data (with basket detection and basket point elimination)
	this->filter_pc(&pcl_cloud_merged, true); //david !!! 18.10.2011
	//Downsampling point cloud
	//this->downsampling_pc(&pcl_cloud_merged);

	//cluster point cloud (and publish segmented point clouds, and nr. of segmented clusters)
	//this->segment_pc(&pcl_cloud_merged);

    //publish manipulated and merged point cloud data (in world coordinate system)
    pcl::toROSMsg(pcl_cloud_merged, this->pc_for_basketdet_out);
    this->pc_for_basketdet_out.header.frame_id = "/world";
	pc_for_basketdet_pub.publish(this->pc_for_basketdet_out);
	ROS_INFO("nach basket detection publish");
	//PUBLISH POINTCLOUD WITHOUT SEGMENTATION and fixed (=1) this->nr_segmented_pc_pub.publish(j_string);
	std_msgs::String tmp_string;
	std::stringstream tmpss;
	tmpss << 1;
	tmp_string.data = tmpss.str();
	//next 2 lines (un)comment always together!
	this->nr_segmented_pc_pub.publish(tmp_string);

	//for Kate/Karthik: output of point cloud without basket in camera coordinate system (basket detection is done a second time)
	pcl::PointCloud<pcl::PointXYZ> pcl_cam1_kate;
	pcl::PointCloud<pcl::PointXYZ> pcl_cam1_kate2;
	fromROSMsg(pc_cam1, pcl_cam1_kate);
	pcl_cam1_kate2 = pcl_cam1_kate;
	//this->filter_pc(&pcl_cam1_kate2, false);	//delete basket, cut area
	pcl::PointCloud<PointXYZRC>::Ptr pc_out_without_basket (new pcl::PointCloud<PointXYZRC>);//define new output ROS message
	this->filter_pc_add_xyz(pcl_cam1_kate2.makeShared(),pc_out_without_basket,false);
	//retransform in camera coordinate system
	pcl::PointCloud<PointXYZRC> pc_out_without_basket2;
    //toROSMsg(pcl_cam1_kate2,pc_out_without_basket);  	//evtl. * vor this; transform pcl to ROS message
    //pc_out_without_basket.header = pc_cam1.header;
	//pc_out_without_basket.header.frame_id = pc_cam1.header.frame_id;
	//std::cerr << "pc_out_without_basket: " << std::endl;
    //std::cerr << *pc_out_without_basket << std::endl;


	//search for tf transform for pc from world to cam1 and make transform
	bool foundTransform = tf_listener->waitForTransform("/openni_depth_optical_frame", "/world", pc_cam1.header.stamp, ros::Duration(3.0));
	if (foundTransform)
	{
	  ROS_INFO("Re-Transform for Kate/Karthik (pc_cam1;openni_depth_optical_frame;world found");
	  pcl::PointCloud<pcl::PointXYZ> p1, p2;
	  PointXYZRC2PointXYZ(*pc_out_without_basket,p1);
	  p1.header.frame_id = "/world";
	  pcl_ros::transformPointCloud("/openni_depth_optical_frame", p1, p2, *tf_listener);
	  PointXYZ2PointXYZRC(p2,*pc_out_without_basket,pc_out_without_basket2);
	  //pc_out_without_basket2.header.frame_id = "/openni_depth_optical_frame";
	}
	else {
	    ROS_WARN("No pc_cam1 (Kate/Karthik) transform found");
	}
	pc_out_without_basket2.header.frame_id="/openni_depth_optical_frame";
	pc_for_basketdet_cam1_pub.publish(pc_out_without_basket2);

    pc_cam1_filled = false;
	pc_cam2_filled = false;
}

// filter point cloud and cut of points outside a defined region
void CPCMerge::filter_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged, bool pub_basket_center, float x_min, float x_max, float y_min, float y_max, float z_min, float z_max )
{
	pcl::PointCloud<pcl::PointXYZ>::Ptr pc_for_basketdet (new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZ>::Ptr final (new pcl::PointCloud<pcl::PointXYZ>);
	// Create the filtering object
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_z (new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_y (new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_x (new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
    *cloud = *pcl_cloud_merged;
	pcl::PassThrough<pcl::PointXYZ> pass;

	ROS_INFO("Filtering outliers and cutting region");

	std::cerr << "Cloud before filtering/cutting: " << std::endl;
	std::cerr << *cloud << std::endl;

	//Filter w.r.t. axis z
	pass.setInputCloud (cloud);
	pass.setFilterFieldName ("z");
	pass.setFilterLimits (z_min, z_max);
	//pass.setFilterLimitsNegative (true);
	pass.filter (*cloud_filtered_z);

	//Filter w.r.t. axis y
	pass.setInputCloud(cloud_filtered_z);
	pass.setFilterFieldName ("y");
	pass.setFilterLimits (y_min, y_max);
	pass.filter (*cloud_filtered_y);

	//Filter w.r.t. axis x
	pass.setInputCloud(cloud_filtered_y);
	pass.setFilterFieldName ("x");
	pass.setFilterLimits (x_min, x_max);
	pass.filter (*cloud_filtered_x);

	std::cerr << "Cloud after cutting and before outlier filtering: " << std::endl;
	std::cerr << *cloud_filtered_x << std::endl;

	//Create the filtering object
	pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
	sor.setInputCloud(cloud_filtered_x);
	sor.setMeanK(50);
	sor.setStddevMulThresh (1.0);
	sor.filter(*pcl_cloud_merged);

	std::cerr << "Cloud after outlier filtering: " << std::endl;
	std::cerr << *pcl_cloud_merged << std::endl;


	//NEW BASKET DETECTION
	double x_mi = 1000;
	double x_ma = -1000;
	double y_mi = 1000;
	double y_ma = -1000;
	for (unsigned int i = 0; i < pcl_cloud_merged->points.size(); ++i){
		if (pcl_cloud_merged->points[i].z > 0.05 and pcl_cloud_merged->points[i].z < 0.08){
			if (pcl_cloud_merged->points[i].x > x_ma)
				x_ma = pcl_cloud_merged->points[i].x;
			if (pcl_cloud_merged->points[i].x < x_mi)
				x_mi = pcl_cloud_merged->points[i].x;
			if (pcl_cloud_merged->points[i].y > y_ma)
				y_ma = pcl_cloud_merged->points[i].y;
			if (pcl_cloud_merged->points[i].y < y_mi)
				y_mi = pcl_cloud_merged->points[i].y;
		}
	}

	// with calibrated cameras th -> < 0.1 and 0.85
	double th = 0.028;  //treshhold
	double th_z = 0.10; //threshold value for height of box
	//delete box
	for (unsigned int i = 0; i < pcl_cloud_merged->points.size(); ++i){
		if (pcl_cloud_merged->points[i].z < th_z and
			((pcl_cloud_merged->points[i].x < x_mi + th and pcl_cloud_merged->points[i].x > x_mi - th ) or
			(pcl_cloud_merged->points[i].x < x_ma + th and pcl_cloud_merged->points[i].x > x_ma - th ) or
			(pcl_cloud_merged->points[i].y < y_mi + th and pcl_cloud_merged->points[i].y > y_mi - th ) or
			(pcl_cloud_merged->points[i].y < y_ma + th and pcl_cloud_merged->points[i].y > y_ma - th )))
		{
			//ROS_INFO("Point belongs to basket");
			continue;
		} else {
			pcl::PointXYZ pnt_tmp = pcl_cloud_merged->points[i];
			pc_for_basketdet->push_back(pnt_tmp);
		}
	}
	//assign (basket-)filtered point cloud to input point cloud
	*pcl_cloud_merged = *pc_for_basketdet;

	if (pub_basket_center){
		//Publish corner points of basket
		std_msgs::String msgStrCorners;
		std::stringstream ss;
		ss << (x_ma + x_mi)/2 << " "  << (y_ma + y_mi)/2;
	    msgStrCorners.data = ss.str();
		center_basket_pub.publish(msgStrCorners);
	}
	//END BASKET DETECTION
}

// filter point cloud and cut of points outside a defined region
void CPCMerge::filter_pc_add_xyz(pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_merged,
		                         pcl::PointCloud<PointXYZRC>::Ptr pc_for_basketdet,
		                         bool pub_basket_center, float x_min, float x_max, float y_min,
		                         float y_max, float z_min, float z_max )
{
	pcl::PointCloud<PointXYZRC>::Ptr final_cloud (new pcl::PointCloud<PointXYZRC>);
	pcl::PointCloud<PointXYZRC>::Ptr final (new pcl::PointCloud<PointXYZRC>);
	// Create the filtering object
	pcl::PointCloud<PointXYZRC>::Ptr cloud_filtered_z (new pcl::PointCloud<PointXYZRC>);
	pcl::PointCloud<PointXYZRC>::Ptr cloud_filtered_y (new pcl::PointCloud<PointXYZRC>);
	pcl::PointCloud<PointXYZRC>::Ptr cloud_filtered_x (new pcl::PointCloud<PointXYZRC>);
    pcl::PointCloud<PointXYZRC>::Ptr cloud (new pcl::PointCloud<PointXYZRC>);
    // transform point cloud -- is it necessary?
    PointXYZ2PointXYZRC(*pcl_cloud_merged,*cloud);

    // filter point cloud
    pcl::PassThrough<PointXYZRC> pass;

	ROS_INFO("Filtering outliers and cutting region");

	std::cerr << "Cloud before filtering/cutting: " << std::endl;
	std::cerr << *cloud << std::endl;

	//Filter w.r.t. axis z
	pass.setInputCloud (cloud);
	pass.setFilterFieldName ("z");
	pass.setFilterLimits (z_min, z_max);
	//pass.setFilterLimitsNegative (true);
	pass.filter (*cloud_filtered_z);

	//Filter w.r.t. axis y
	pass.setInputCloud(cloud_filtered_z);
	pass.setFilterFieldName ("y");
	pass.setFilterLimits (y_min, y_max);
	pass.filter (*cloud_filtered_y);

	//Filter w.r.t. axis x
	pass.setInputCloud(cloud_filtered_y);
	pass.setFilterFieldName ("x");
	pass.setFilterLimits (x_min, x_max);
	pass.filter (*cloud_filtered_x);

	std::cerr << "Cloud after cutting and before outlier filtering: " << std::endl;
	std::cerr << *cloud_filtered_x << std::endl;

	//Create the filtering object
	pcl::StatisticalOutlierRemoval<PointXYZRC> sor;
	sor.setInputCloud(cloud_filtered_x);
	sor.setMeanK(50);
	sor.setStddevMulThresh (1.0);
	//final_cloud = new pcl::PointCloud<PointXYZRC>;
	sor.filter(*final_cloud);

	std::cerr << "Cloud after outlier filtering: " << std::endl;
	std::cerr << *final_cloud << std::endl;


	//NEW BASKET DETECTION
	double x_mi = 1000;
	double x_ma = -1000;
	double y_mi = 1000;
	double y_ma = -1000;
	for (unsigned int i = 0; i < final_cloud->points.size(); ++i){
		if (final_cloud->points[i].z > 0.05 and final_cloud->points[i].z < 0.08){
			if (final_cloud->points[i].x > x_ma)
				x_ma = final_cloud->points[i].x;
			if (final_cloud->points[i].x < x_mi)
				x_mi = final_cloud->points[i].x;
			if (final_cloud->points[i].y > y_ma)
				y_ma = final_cloud->points[i].y;
			if (final_cloud->points[i].y < y_mi)
				y_mi = final_cloud->points[i].y;
		}
	}

	// with calibrated cameras th -> < 0.1 and 0.85
	double th = 0.028;  //treshhold
	double th_z = 0.10; //threshold value for height of box
	//delete box
	for (unsigned int i = 0; i < final_cloud->points.size(); ++i){
		if (final_cloud->points[i].z < th_z and
			((final_cloud->points[i].x < x_mi + th and final_cloud->points[i].x > x_mi - th ) or
			(final_cloud->points[i].x < x_ma + th and final_cloud->points[i].x > x_ma - th ) or
			(final_cloud->points[i].y < y_mi + th and final_cloud->points[i].y > y_mi - th ) or
			(final_cloud->points[i].y < y_ma + th and final_cloud->points[i].y > y_ma - th )))
		{
			//ROS_INFO("Point belongs to basket");
			continue;
		} else {
			PointXYZRC pnt_tmp = final_cloud->points[i];
			pc_for_basketdet->push_back(pnt_tmp);
		}
	}
	//assign (basket-)filtered point cloud to input point cloud
	pc_for_basketdet->width = pc_for_basketdet->points.size();
	pc_for_basketdet->height = 1;
	//*final_cloud = *pc_for_basketdet;

	//std::cerr << "pc_for_basketdet 22: " << std::endl;
	//std::cerr << *pc_for_basketdet << std::endl;

	if (pub_basket_center){
		//Publish corner points of basket
		std_msgs::String msgStrCorners;
		std::stringstream ss;
		ss << (x_ma + x_mi)/2 << " "  << (y_ma + y_mi)/2;
	    msgStrCorners.data = ss.str();
		center_basket_pub.publish(msgStrCorners);
	}
	//END BASKET DETECTION
}

// downsampling: reduce the number of points of the pc
void CPCMerge::downsampling_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged )
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in (new pcl::PointCloud<pcl::PointXYZ>);
    *cloud_in = *pcl_cloud_merged;

    std::cerr << "PointCloud before downsampling: " << cloud_in->width * cloud_in->height
           << " data points (" << pcl::getFieldsList (*cloud_in) << "). \n";

    // Create the VoxelGrid object
     pcl::VoxelGrid<pcl::PointXYZ> vg;
     vg.setInputCloud (cloud_in);
     vg.setLeafSize (0.01, 0.01, 0.01);
     vg.filter (*pcl_cloud_merged);

     std::cerr << "PointCloud after downsampling: " << pcl_cloud_merged->width * pcl_cloud_merged->height
            << " data points (" << pcl::getFieldsList (*pcl_cloud_merged) << "). \n";
}



// segment the merged, filtered, downsampled point cloud
void CPCMerge::segment_pc(pcl::PointCloud<pcl::PointXYZ> * pcl_cloud_merged )
{
	using namespace pcl;
	using namespace std;

    PointCloud<PointXYZ>::Ptr cloud_in (new PointCloud<PointXYZ>);
    *cloud_in = *pcl_cloud_merged;

    PCDWriter writer;

    // Creating the KdTree object for the search method of the extraction
    KdTree<PointXYZ>::Ptr tree (new KdTreeFLANN<PointXYZ>);
    tree->setInputCloud (cloud_in);

    vector<PointIndices> cluster_indices;
    EuclideanClusterExtraction<PointXYZ> ec;
    ec.setClusterTolerance (0.02); // 2cm
    ec.setMinClusterSize (50);
    ec.setMaxClusterSize (25000);
    ec.setSearchMethod (tree);
    ec.setInputCloud( cloud_in);
    ec.extract (cluster_indices);

    int j = 0;
    for (vector<PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)
    {
        PointCloud<PointXYZ>::Ptr cloud_cluster (new PointCloud<PointXYZ>);
        for (vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); pit++)
            cloud_cluster->points.push_back (cloud_in->points[*pit]);

        cloud_cluster->width = cloud_cluster->points.size();
        cloud_cluster->height = 1;
        cloud_cluster->header = cloud_in->header;
        cloud_cluster->is_dense = cloud_in->is_dense;

        cerr << "PointCloud representing the Cluster: " << cloud_cluster->points.size () << " data points." << endl;
        stringstream ss;
        ss << "cloud_cluster_" << j << ".pcd";
        writer.write<PointXYZ> (ss.str (), *cloud_cluster, false);


        //publish manipulated point clusters
        sensor_msgs::PointCloud2 cluster_out;
        toROSMsg(*cloud_cluster,cluster_out);

        cluster_out.header.frame_id = cloud_in->header.frame_id;
        cloud_cluster->is_dense = cloud_in->is_dense;


        cluster_out.header = cloud_cluster->header; //new 21.11.2011
        cluster_out.header.frame_id = cloud_in->header.frame_id;
        this->pc_merged_pub.publish(cluster_out);

        j++;
    }
    std_msgs::String j_string;
    stringstream ss;
    ss << j;
    j_string.data = ss.str();
    this->nr_segmented_pc_pub.publish(j_string);
}




void CPCMerge::pc_cam1_callback(const sensor_msgs::PointCloud2ConstPtr& pcl_in)
{
  m.lock();
  ROS_INFO("pc_cam1 received");
  sensor_msgs::PointCloud2 pcl_out;

  //search for tf transform for pc from cam1
  bool foundTransform = tf_listener->waitForTransform("/world", "/openni_depth_optical_frame",  (*pcl_in).header.stamp, ros::Duration(3.0));
  if (foundTransform)
  {
    ROS_INFO("Transform pc_cam1: openni_depth_optical_frame to world found");
    pcl_ros::transformPointCloud("/world", *pcl_in, pcl_out, *tf_listener);
  }
  else {
    ROS_WARN("No pc_cam1 transform found");
  }

  this->pc_cam1 = pcl_out;
  this->pc_cam1_filled = true;

  //publishes point cloud if pc from cam2 allready arrived or if only one camera is used
  if (this->pc_cam2_filled or !this->use_two_cams)
  {
	this->publish_merged_pc();
  }
  m.unlock();
}


void CPCMerge::pc_cam2_callback(const sensor_msgs::PointCloud2ConstPtr& pcl_in)
{
  ROS_INFO("pc_cam2 received");
  sensor_msgs::PointCloud2 pcl_out; // initializing missing??????????

  //search for tf transform for pc from cam1
  bool foundTransform = tf_listener->waitForTransform("/world", "/openni_depth_optical_frame2",  (*pcl_in).header.stamp, ros::Duration(3.0));
  if (foundTransform)
  {
    ROS_INFO("Transform pc_cam2: openni_depth_optical_frame to world found");
    pcl_ros::transformPointCloud("/world", *pcl_in, pcl_out, *tf_listener);
  }
  else {
    ROS_WARN("No pc_cam2 transform found");
  }

  this->pc_cam2 = pcl_out;
  this->pc_cam2_filled = true;
  if (this->pc_cam1_filled == true)
  {
	  this->publish_merged_pc();
  }
}



int main (int argc, char** argv)
{
  ROS_INFO("ROS NODE pc_merge_with_basket started");
  ros::init(argc, argv, "pc_merge");
  ros::NodeHandle nh;
  tf_listener = new tf::TransformListener();
  CPCMerge * pc_merge = new CPCMerge(nh);

  ros::spin();
  delete tf_listener;
  return (0);
}
