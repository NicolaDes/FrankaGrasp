//============================================================================
// Name        : feature_creator.cpp
// Author      : David Fischinger
// Version     :
// Copyright   : Your copyright notice
// Description : Generates Haar-like Features
//				 which are weighted such that the result is 0 if heights would be equal
//============================================================================

#include <iostream>
#include <fstream>
#include <ostream>
#include <cstdlib>
#include <iomanip>
#include <string>
using namespace std;

void printR(int *R1, int *R2);

int main () {

	int cntskip=0;
	int *R1, *R2; //saves x1, x2, y1, y2
	R1 = new int[4];
	R2 = new int[4];


	ofstream fileout("/home/grasp/temp/featuresout.txt");
	R2[0] = 0;
	R2[1] = -1;
	R2[2] = 0;
	R2[3] = 0;

	int cnt=0;
	for (int sx = -3; sx < 4; sx++){ //shift x
		for (int sy = -3; sy < 4; sy++){
			for (int x1 = 0; x1 < 7; x1++){
				int x2 = 13-x1;
				for (int y1 = 0; y1 < 7; y1++){
					int y2 = 13-y1;
					R1[0] = x1+sx;
					R1[1] = x2+sx;
					R1[2] = y1+sy;
					R1[3] = y2+sy;

					int lxR1, lyR1; //length of R1 in x (lxR1) and y (lyR1) direction
					lxR1 = R1[1]-R1[0]+1;
					lyR1 = R1[3]-R1[2]+1;
					if (R1[0] >=0 and R1[1] <=13 and R1[2] >=0 and R1[3] <=13	//region1 still in frame
							and lxR1 >= 1 and lyR1 >= 3		//region1 has propriate dimension
							and R1[0] <=6 and R1[1] >= 7	//region1 not completely outside center (x-axis)
							and R1[2] <= 6 and R1[3] >= 7){ //region1 not completely outside center (y-axis)
						//inner region (Region 2)
						for (int x1r2 = R1[0]; x1r2 <= R1[1]; x1r2++){	//x1 of region2 inside region1
							for (int x2r2 = x1r2; x2r2 <= R1[1]; x2r2++){  //x2 of region2 inside region1
								for (int y1r2 = R1[2]+2; y1r2 <= R1[3]-2; y1r2++ ){
									for (int y2r2 = y1r2; y2r2 <= R1[3]-2; y2r2++){

										R2[0] = x1r2;
										R2[1] = x2r2;
										R2[2] = y1r2;
										R2[3] = y2r2;
										int lxR2 = R2[1]-R2[0]+1;
										int lyR2 = R2[3]-R2[2]+1;

										if (lxR2 >= 3 and lyR2 >= 1 and lxR2*lyR2 >=4   // min size
												and (R2[0]+R2[1])
												and R2[0] <=6 and R2[1] >= 7	//region2 not completely outside center (x-axis)
												and R2[2] <= 6 and R2[3] >= 7	//region2 not completely outside center (y-axis)
												and (R1[1]-R2[1] < 2) and (R2[0]-R1[0] < 2) //not to many colums outside region1
												and R2[2]+R2[3] >= 12 and R2[2]+R2[3] <= 14){ //region2 in average centered (y-axis)


											cntskip++;
											if (cntskip % 10 == 1) {  // take only one feature out of 100
											//fehlt noch: check ob R1+R2 schon vergekommen
												cout << "\n cnt: " << cnt++ << endl;
												double wR1 = -1;
												double wR2 = (1.0*lxR1*lyR1)/(lxR2*lyR2);
												fileout << R1[0] << "\t" << R1[1] << "\t" << R1[2] << "\t" << R1[3] << "\t" << R2[0] << "\t" << R2[1] << "\t" << R2[2] << "\t" << R2[3]
								                        << "\t" << 0 << "\t" << 0 << "\t" << 0 << "\t" << 0 << "\t" << 0 << "\t" << 0 << "\t" << 0 << "\t" << 0
								                        << "\t" << wR1 << "\t" << wR2 << "\t" << 0.0 << "\t" << 0.0 << endl;

												printR(R1,R2);
												int input;
												//cin >> input;

												//calc weights: wR1: -1  wR2: AR1/AR2 !!!
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	//printR(R1,R2);
	fileout.close();
	return 0;
}


void printR(int *R1, int *R2){

	cout << R1[0] << "\t" << R1[1] << "\t" << R1[2] << "\t" << R1[3] << "\n" << R2[0] << "\t" << R2[1] << "\t" << R2[2] << "\t" << R2[3] << endl;

	for (int j = 0; j < 14; j++){
		cout << "\t" << j ;
	}
	cout << endl;
	for (int i = 0; i < 14; i++){
		cout << i << "\t";
		for (int j = 0; j < 14; j++){

			//print R1
			if (j >= R2[0] and j <= R2[1] and i >= R2[2] and i <= R2[3]){
				cout << "--" << "\t";
			} else if (j >= R1[0] and j <= R1[1] and i >= R1[2] and i <= R1[3]){
				cout << "R1" << "\t";
			} else {
				cout << "  " << "\t";
			}


		}
		cout << endl;
	}
}
