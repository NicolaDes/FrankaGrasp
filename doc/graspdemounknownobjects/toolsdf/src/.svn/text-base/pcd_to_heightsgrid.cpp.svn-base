/*
 * David Fischinger -TUW
 * 10.11.2011
 *
 * input:
 *   Programm reads pcd-files from given path using the
 *   Filenames given in path/ListOfPCDFilenames.txt which is generated by
 *   ls pcd* -1 > ListOfPCDFilenames.txt (assuming all point clouds start with "pcd"
 *   and no other files start with "pcd"
 *
 * output:
 * 	 saves files with max heights grid for each input file
 *   (optional: shows grid of point cloud with TomGine)
 *
 * PARAMETERS:
 *
 * 	path =    "/home/grasp/David/GPDatabase/badgps/twocams/badmanual/";				path where files are read from
 *  pathout = "/home/grasp/David/GPDatabase/badgps/twocams/badmanual/heights/"; 	path where files are written to
 *
 * 	TGHEIGHT	height for tomgine output
 * 	TGWIDTH		width for tomgine output
 * 	HEIGHT		height (rows) for heightsgrid
 *	WIDTH		width (cols) for heightsgrid
 *
 */

#include <iostream>
#include "std_msgs/String.h"
#include <string.h>
#include <sstream>
#include <fstream>
#include <iomanip>

#include "pcl/common/common_headers.h"
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include "pcl/io/io.h"

#include <v4r/TomGine/tgTomGine.h>
#include <time.h>
#include <unistd.h>

#define TGHEIGHT 600
#define TGWIDTH 800
#define HEIGHT 14
#define WIDTH 14

using namespace std;
using namespace TomGine;



void print_heights(double heightsgrid[][WIDTH])
{
    //print heights matrix
	cout << "print heights matrix:" << endl;
	for (int i = 0; i < HEIGHT; i++){  //rows
		for (int j = 0; j < WIDTH; j++){  //cols
			cout << setw(10) << setprecision(3) << heightsgrid[i][j];
		}
		cout << "\n";
	}
}

void save_heightsgrid(double heightsgrid[][WIDTH], string fullPathGridOut)
{
	ofstream out_file( fullPathGridOut.c_str() );
    //save heightsgrid as vector/line/row to file
	for (int i = 0; i < HEIGHT; i++){  //rows
		for (int j = 0; j < WIDTH; j++){  //cols
			out_file << heightsgrid[i][j] << "\t";
		}
		out_file << "\n";
	}
	out_file.close();
	cout << "This file was saved: " << fullPathGridOut << endl;
}


//Shows heights grid for disc with TomGine
void show_heights(double heightsmat[][WIDTH]) {

	//TomGine
  	tgTomGineThread tgThread(TGWIDTH, TGHEIGHT);
	tgRenderModel hboxes[HEIGHT][WIDTH];	//height box: box for visual display of max height per segment

	tgThread.ClearModels();
	double x_rad=0.1, y_rad=0.1, hgt = 0;
	for (int row = 0; row < HEIGHT; row++) {
		for (int col = 0; col < WIDTH; col++) {
			hboxes[row][col].Clear();															//clear old boxes models!!!
			hboxes[row][col].m_pose.t.x = row/10.0;		//x-coordinate for one box
			hboxes[row][col].m_pose.t.y = col/10.0; 	//y-coordinate for one box
			hgt = 10*heightsmat[row][col];						//height from variable matrix
			hboxes[row][col].m_pose.t.z = hgt/2;							//z-coordinate for one box
			tgShapeCreator::CreateBox(hboxes[row][col],x_rad ,y_rad,hgt);	//create box
			tgThread.AddModel(&hboxes[row][col]);
		}
	}
	tgThread.Update();
	sleep(5);
}


int main (int argc, char** argv)
{
	//PARAMETERS
	int nr_rows = HEIGHT;
	int nr_cols = WIDTH;
	string path = "/home/grasp/David/GPDatabase/badgps/twocams/badmanual/";
	string pathfull_list_of_filenames = path + "ListOfPCDFilenames.txt";
	string pathout = "/home/grasp/David/GPDatabase/badgps/twocams/badmanual/heights/";

	pcl::PointXYZ pnt;  		//point for loop
 	double heightsgrid[HEIGHT][WIDTH];
 	ifstream filenames_pcd(pathfull_list_of_filenames.c_str());

 	int cnt =0;
	// loop which reads all pcd-files
	string filename_cur_pcd;
 	getline(filenames_pcd, filename_cur_pcd);
	while (!filenames_pcd.eof())
	{
		cout << ++cnt << endl;
		pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in (new pcl::PointCloud<pcl::PointXYZ>);		//pcd in
		stringstream ss_file_in;	//pcd file in
		stringstream ss_file_out;	//txt with maxheights grid
		ss_file_in << path << filename_cur_pcd;
		ss_file_out << pathout << filename_cur_pcd.substr(0,filename_cur_pcd.length()-4) << ".txt"; //delete ".pcd"
		if (pcl::io::loadPCDFile<pcl::PointXYZ> (ss_file_in.str(), *cloud_in) == -1) //load the file
		{
			cout << "\n Couldn't read file (%d) \n" << filename_cur_pcd << endl;
			continue;
		}

		//set heights to 0
		for (int i = 0; i < nr_rows; i++)
			for (int j = 0; j < nr_cols; j++)
				heightsgrid[i][j]= 0.0;

		for (int i = 0; i < cloud_in->points.size(); ++i)
		{
			//ASSUMING point cloud is centered w.r.t. (0,0)
			int idx_x = -1, idx_y = -1;
			pnt = cloud_in->points[i];
			double r_100 = (0.5 * (double)nr_cols)/100.0;

			if ((pnt.x > -r_100) and (pnt.x < r_100) and (pnt.y > -r_100) and (pnt.y < r_100))
			{ //point is relevant for object grid
				idx_x = (int) (pnt.x * 100 + 0.5 * (double)nr_cols);
				//cout << "index x: " << idx_x  << endl;
				idx_y = (int) (pnt.y * 100 + 0.5 * (double)nr_rows);
				//cout << "index y: " << idx_y  << endl;
				if (heightsgrid[idx_x][idx_y] < pnt.z)
				{
					heightsgrid[idx_x][idx_y] = pnt.z;
				}
			}
		}
		save_heightsgrid(heightsgrid, ss_file_out.str());
		//print_heights(heightsgrid);
		//show_heights(heightsgrid);
		getline(filenames_pcd, filename_cur_pcd);
	}
	filenames_pcd.close();
	return 0;
}
